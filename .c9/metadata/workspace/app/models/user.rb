{"filter":false,"title":"user.rb","tooltip":"/app/models/user.rb","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":2,"column":0},"action":"remove","lines":["class User < ActiveRecord::Base","end",""],"id":2},{"start":{"row":0,"column":0},"end":{"row":57,"column":3},"action":"insert","lines":["class User < ActiveRecord::Base","","  before_save :downcase_email","  attr_accessor :remember_token","  validates :name, presence: true, length: {maximum: 50}","  validates :password, presence: true, length: {minimum: 6}, allow_nil: true","","  has_many :grades","  has_many :courses, through: :grades","","  has_many :teaching_courses, class_name: \"Course\", foreign_key: :teacher_id","","  VALID_EMAIL_REGEX = /\\A[\\w+\\-.]+@[a-z\\d\\-.]+\\.[a-z]+\\z/i","  validates :email, presence: true, length: {maximum: 255},","            format: {with: VALID_EMAIL_REGEX},","            uniqueness: {case_sensitive: false}","","  #1. The ability to save a securely hashed password_digest attribute to the database","  #2. A pair of virtual attributes (password and password_confirmation), including presence validations upon object creation and a validation requiring that they match","  #3. An authenticate method that returns the user when the password is correct (and false otherwise)","  has_secure_password","  # has_secure_password automatically adds an authenticate method to the corresponding model objects.","  # This method determines if a given password is valid for a particular user by computing its digest and comparing the result to password_digest in the database.","","  # Returns the hash digest of the given string.","  def User.digest(string)","    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :","        BCrypt::Engine.cost","    BCrypt::Password.create(string, cost: cost)","  end","","  def User.new_token","    SecureRandom.urlsafe_base64","  end","","  def user_remember","    self.remember_token = User.new_token","    update_attribute(:remember_digest, User.digest(remember_token))","  end","","  def user_forget","    update_attribute(:remember_digest, nil)","  end","","  # Returns true if the given token matches the digest.","  def user_authenticated?(attribute, token)","    digest = self.send(\"#{attribute}_digest\")","    return false if digest.nil?","    BCrypt::Password.new(digest).is_password?(token)","  end","","  private","","  def downcase_email","    self.email = email.downcase","  end","","end"]}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":23,"column":0},"end":{"row":23,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1509964554416,"hash":"88e0036d9da9f1b9a36d9b57ae86f06313c4f5f2"}